---
layout: post
title: "The Hardest Part Of Technology"
date: 2020-10-06
tags: people process problems technology
author: Hamish Tedeschi
image: img/people.jpg
---

## Background

Mechanical Rock is a technical consultancy. At times we can be accused of trying to solve every problem presented to us with a technical solution. Unfortunately, this can be true, although we work hard to rectify this and we also spend a lot of time challenging conventional thinking using processes like [Impact Mapping](https://www.impactmapping.org/}) to ascertain the value of potential projects before engaging with customers or before building something. We have been known to turn down projects or price ourselves out because we believe it is doomed to fail, or the environment is not conducive to success.

The difference between technologists that can look at a bigger picture and those that don't or can't can be a chasm at times. Many engineers tend to want to write code and not do much else. But the best code, is no code at all!

## The Software Lifecycle

A natural flow in programming is something like this:

1. _Someone_ has a problem
2. The team attempts to understand the problem by talking to _someone_
3. The team works out _if_ the problem can be solved in code
4. The team works out _if_ the problem should be solved in code
5. The team codifies the solution, which includes feedback cycles

> Does this mean that the bulk of the work in programming is non-programming activities?

Engineers who want to progress, often want the salary associated with more responsibility, but are not a good fit for the expectations associated with that increase in salary. This is succinctly articulated by the Peter Principle:

> "People are promoted to their level of incompetence, suggesting that something is fundamentally misaligned in the promotion process"

The dearth of technical talent and the rise of big tech [FAANG](https://en.wikipedia.org/wiki/Big_Tech), has contributed to the expectation of big salaries in the industry. It is not uncommon for engineers to be paid above the odds, but they are not given a "wider remit" reflective of that. Instead, continuing to simply solving problems with code. I've noticed that many engineers do not value skills outside of programming and believe they are capable of doing these non-programming activities. They treat the skills like a checklist of activities and the qualitative aspect goes out the window. It is not until they are given the opportunity that they realise they aren't capable. Or worse, they are given the opportunity, perform poorly but do not have the self awareness or personal reflection to realise the chasm between those that can and those that can't.

So, what is this *wider remit*, whilst still remaining "on the keys"?

## A Wider Remit in Software Delivery

What is a wider remit in software delivery terms? Lets use the 5 items identified above and tease out the skills required to be successful at each.

1. A **problem** tends to infer that you need a solution. Often what we call a problem is an solution to an existing problem. And to come up with this needs **creativity** and often, but not always **business acumen**. How can we solve an existing problem in new ways. Although, if one more person comes to me and says, "Hamish, I have an idea for an app.." I think I may scream.

2. Attempting to **understand the problem** is my favourite part of any project. Many times you need to get to grips with a new domain, new acronyms and new ideas. To understand the problem fully you need to immerse yourself in it. It requires **empathy** to capture the nuance of what people are telling you (many times said or unsaid), it requires high degrees or **preparation** to ensure you can plan this activity effectively but most of all **communication** skills to exchange and solidify understanding.

3. To understand if the **problem can be solved in code** you should scrutinise it in a team setting by using examples. This requires **convergent** and **divergent** thinking and again that old **communication** chestnut. Communication is not just about talking. It is about the effective exchange of information. If people don't understand you **and** trust you when talking to them, then it is a one way conversation and not communication.

4. To understand if the **problem should be solved in code** you need to go back to the problem domain and question where the value lies. This requires challenging conventional thinking and in essence **debating** skills. Many times the person who has come up with the problem has already made up their mind on what the solution should look like - "It has to be a web app" or "It must be a native app", when it could be delivered via Google Forms, with no code.

5. **Coding skills** are still very important. There are many ways to write code; one way is going to be the right way to someone and you can guarantee that the same way is also the wrong way to someone. But coding is still only one part of it. We need to get feedback on everything we develop either directly with the Problem Owner (preferred) or via an intermediary. This again requires **communication** skills to exchange and solidify understanding.

## It Doesn't Stop There

Building software is not just about solving problems. It is also about helping others solve problems too. Part of any "wider remit" would be a coaching, mentoring and leadership aspect, whilst remaining technical. 

- how do we plan and bring it all together
- how do we ensure everyone on the team is getting the support they need
- how do we deliver software aligned to our companies goal and vision

Planning is an underrated activity. In the words of Benjamin Franklin.. 

> "Failing to plan is planning to fail"

A technologist who can plan the build of an application, especially complex multi team, multi disciplined builds, often grasps the goals better than most. They are good with people and above all have excellent communication skills.

So when a job interview is a tech challenge only, the company is recruiting for people that can solve only one fifth of the problem domain. Yes, but we have Product Owners and Business Analysts to do that! No, someone still has to communicate it to the development team and they still have to understand you. And in the process you have just introduced another layer; another silo; another hurdle to overcome.

Programming is hard. People are harder.