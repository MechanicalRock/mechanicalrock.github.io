---
layout: postv2
inject_optimize_tag: true
title: "How a Simple Configuration Almost Compromised Our Application"
description: "Discover how a single misconfiguration in Amazon CloudFront led to a security vulnerability, exposing user data to potential risk, and the steps we took to resolve it."
date: 2024-11-05
highlight: monokai
author: Caio K. Kaihara
image: /img/2024-11-05-how-a-simple-configuration-almost-compromised-our-application/hero.png
tags: [
  "CloudFront caching",
  "AWS security",
  "session hijacking",
  "Okta integration",
  "web application security",
  "AWS Well-Architected Framework"
]
---

# How a Simple Configuration Error Almost Compromised Our Application

Imagine logging into an application and suddenly viewing someone else’s account. As alarming as this sounds, it was nearly a reality in one of our applications. In this post, we’ll detail how a simple misconfiguration in Amazon CloudFront led to a security vulnerability and how we managed to resolve it.

#### The Problem: Cross-User Data Exposure

During extended testing, we identified a security vulnerability within the authentication process. Despite using OKTA as our identity provider, we observed sporadic occurrences of session hijacking, where authenticated users unexpectedly accessed other users’ sessions. Although infrequent, this issue posed a significant risk to data security.

Initially, we suspected that the issue was related to user IDs in the database. During development, these IDs were randomly generated with each insertion, meaning a single user could have different IDs over time. This inconsistency, combined with the way we used cookies to store session IDs, seemed to open the door to unauthorised access.

To address this, we forced the assignment of a unique ID for each user in every new iteration, but the problem persisted after days of testing. We then decided to investigate the HTTP requests between the client and the server.

#### The Investigation: Discovering CloudFront’s Role

As we analysed the authentication flow, we noticed that, after logging in via OKTA, a session was created and a token was returned to the client. The application then checked if the user had access rights. At this stage, we observed that CloudFront was intercepting these requests. We suspected that, due to improper configuration, CloudFront was caching some of these responses, resulting in one user’s session data being served to another.

#### Cloud Infrastructure Architecture

From the start, we planned the application’s cloud architecture based on the "AWS Well-Architected Framework," adopting a standard structure for web applications.

After numerous diagnostic attempts, we found that CloudFront was using optimised caching policies on certain routes, such as `api/*`.

```typescript
    // ...
    additionalBehaviors: {
        "/api/*": {
            allowedMethods: cloudFront.AllowedMethods.ALLOW_GET_HEAD,
            cachePolicy: cloudFront.CachePolicy.CACHING_OPTIMIZED,
            // ...
        },
        // ...
    },
    // ...
```

See the flow diagram below for a simplified view of both the desired workflow and the issue we encountered:
![CloudFront Caching Issue](/img/2024-11-05-how-a-simple-configuration-almost-compromised-our-application/the-post-img.png)

The diagram shows 2 users, A and B, accessing the application.
User A logs in and receives a token, which is then used to access the application. However, due to the caching policy, User B can sometimes access User A’s session data.

Although no issues were initially detected with this caching policy, we began to suspect that the access token generated by OKTA immediately after login was being ignored, with the application occasionally serving cached responses from other user sessions.

#### The Challenge of Understanding the Issue

The greatest challenge was isolating and understanding the root cause in an environment with multiple components. Uncertainty around whether the issue lay in the OKTA configuration or the application complicated the investigation. We added `console.log` statements in strategic points to monitor CloudFront logs and gather more information.

Additionally, the intermittent nature of the issue made debugging even more challenging. The lack of clear reproduction steps and the absence of automated tests specifically for the authentication flow further complicated our efforts to identify and resolve the problem.

#### The Solution: Disabling CloudFront Caching

The most effective solution was to disable caching in CloudFront for sensitive routes, which resolved the issue. Although we could have created a custom cache policy, disabling the cache was the most practical and secure solution.

#### Lessons Learned

Our experience highlighted several essential points for securely managing CloudFront cache:

1. **Use Strict Cache Policies**: Avoid caching on routes with user-specific or session-based data. Configuring headers like `Cache-Control: private, no-store` for sensitive routes can help prevent unwanted caching.
2. **Align Authentication and Cache Configuration**: Ensure that authentication and authorisation mechanisms are properly integrated with cache configuration, especially when using external providers.
3. **Limit Data in Tokens**: Keep token-stored data minimal and periodically verify essential information directly from the database.

This experience underscored the importance of rigorous testing, not only for code but also for infrastructure when using services like CloudFront in conjunction with external authentication providers.

#### Conclusion: The Importance of Comprehensive Testing for Security

While tests, such as unit, end-to-end (E2E), BDD, and smoke tests, ensure that the code and application functionalities work correctly and that the server is accessible, this experience taught us that in a complex environment with multiple components, these may not be enough. Each system integration, like cache and authentication, should also be tested for expected behaviour across various scenarios, especially under load.

We have not yet developed a fully automated and reliable method for testing cache and authentication scenarios together. However, until that becomes possible, the most important lesson we learned is that it’s essential to subject cache configurations to rigorous testing to ensure the application operates securely and protects all users. In doing so, we minimize the risk of issues like this and ensure the integrity of the user experience and data.

---

#### Links for Further Reading:

- [CloudFront Returning Response for Incorrect User](https://www.reddit.com/r/aws/comments/125l04c/cloudfront_returning_response_for_incorrect_user/)
- [CloudFront Cache Problems and How to Solve Them](https://advancedweb.hu/cloudfront-cache-problems-and-how-to-solve-them/)
- [How to Debug CloudFront Origin Requests](https://advancedweb.hu/how-to-debug-cloudfront-origin-requests/)
- [AWS Well-Architected Framework](https://aws.amazon.com/architecture/well-architected/)